
# 🏇 Knight's Minimum Moves Problem

## 📌 문제 설명

체스판과 유사한 N × M 보드에서 나이트(Knight)가 주어진 시작 위치 (R, C)에서 목표 위치 (S, K)까지 **최소 몇 번의 이동**으로 도달할 수 있는지 구하라. 나이트는 체스 말처럼 L자 형태로 이동한다.

- 이동 가능한 방향은 총 8가지:
  - (-2, -1), (-2, +1)
  - (-1, -2), (-1, +2)
  - (+1, -2), (+1, +2)
  - (+2, -1), (+2, +1)

---

## 📥 입력

```java
public int minKnightMoves(int N, int M, int R, int C, int S, int K)
```

- N, M: 보드의 크기 (1 < N, M ≤ 100)
- R, C: 시작 위치 (1-based index, 1 ≤ R ≤ N, 1 ≤ C ≤ M)
- S, K: 목표 위치 (1-based index, 1 ≤ S ≤ N, 1 ≤ K ≤ M)

---

## 📤 출력

- 최소 이동 횟수 (도달 불가 시 -1 반환)

---

## 💡 문제 해결 접근법

### 1. BFS (너비 우선 탐색) 사용
- 최단 경로 문제는 BFS가 가장 적절
- 큐(Queue)를 활용하여 말이 도달 가능한 지점들을 레벨별로 확장

### 2. 상태 정의
- 노드: 현재 말의 좌표 (x, y)와 이동 횟수 count
- 종료 조건: 현재 위치가 목표 좌표(S, K)에 도달하면 이동 횟수 반환

### 3. 방문 처리
- `visited[N][M]` 배열을 통해 같은 위치 중복 방문 방지

### 4. 주의 사항
- 문제에서 주어진 좌표는 1-based이므로 내부적으로는 0-based로 변환 필요
  - `R--, C--, S--, K--`

---

## ✅ 예시

```java
minKnightMoves(9, 9, 3, 5, 2, 8)
// 시작 위치: (3,5), 목표 위치: (2,8)
// 최소 이동: 2
```

---

## ✅ 시간 및 공간 복잡도

- 시간 복잡도: O(N × M)
- 공간 복잡도: O(N × M)

---

## 📌 키워드

- BFS
- 체스 나이트 이동
- 최단 거리
- 2차원 보드 탐색
